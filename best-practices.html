<html>
<head>
<title>Best Practices for using Jakarta Commons "Discovery" Component</title>
<head>
<body bgcolor="white">


<div align="center">
<h1>Best Practices for using Jakarta Commons "Discovery" Component</h1>
$Id$<br />
<a href="#Introduction">[Introduction]</a>
<a href="#Calling Directly">[Calling Directly]</a>
<a href="#Integrating into Factories : Wrapping">[Integrating into Factories : Wrapping]</a>
<a href="#Service Life Cycle Management">[Service Life Cycle Management]</a>
<a href="#Service Groups">[Service Groups]</a>
<br /><br />
</div>


<a name="Introduction"></a>
<h3>1.  INTRODUCTION</h3>

Best-practices are discussed.
See the javadoc, starting with <code>DiscoverySingleton</code> and <code>DiscoverClass</code>,
for detail on the API:
where service implementations are looked for,
the order in which those places are checked,
which classloaders are used,
and the order in which they are used.


<a name="Calling Directly"></a>
<h3>2.  CALLING DIRECTLY</h3>

<a name="Finding Singleton Instances (Factories)"></a>
<h4>Finding Singleton Instances (Factories)</h3>

<p>DiscoverSingleton finds, loads, and manages the lifecycle of a class implementing
a given interface.  It only supports classes with default (zero-argument) constructors.
DiscoverSingleton can pass a set of properties to the class
(see <a href="#Service Life Cycle Management">[Service Life Cycle Management]</a>).
Use of the term singleton should be applied loosely:
DiscoverSingleton will instantiate separate instances of a class if called with
different:
<ul>
  <li>thread context class loaders
      (for example, within different web applications in a J2EE managed environment)</li>
  <li>group contexts
      (maintain separation between different subsystems, if desired)</li>
</ul>
</p>

<p>To call discovery directly from user-code:
<ul>
<pre>
    import org.apache.commons.discovery.DiscoverSingleton;
    import org.apache.commons.logging.LogFactory;
    ...
    LogFactory logFactory = (LogFactory)DiscoverSingleton.find(LogFactory.class);
</pre>
</ul>
DiscoverSingleton looks for the value of the system property
<code>org.apache.commons.logging.LogFactory</code>
for the name of a class that implements the <code>LogFactory</code> (abstract) class.
Failing that, it uses JDK1.3-style service discovery.
</p>
<p>
DiscoverSingleton also allows a <code>java.util.Properties</code>
parameter to be used for query for service implementation class name,
as well as a default implementation class name:
<ul>
<pre>
    LogFactory factory =
        (LogFactory)DiscoverSingleton.find(LogFactory.class,
                                           properties,
                                           LogFactory.FACTORY_DEFAULT);
</pre>
</ul>
</p>
<p>
The properties can also be specified as a resource name:
<ul>
<pre>
    LogFactory factory =
        (LogFactory)DiscoverSingleton.find(LogFactory.class,
                                           LogFactory.FACTORY_PROPERTIES,
                                           LogFactory.FACTORY_DEFAULT);
</pre>
</ul>
This last form is equivalent in function
to the original <code>LogFactory.getFactory()</code>
method.
</p>
<p>
There are a variety of <code>find</code> methods
provided by <code>DiscoverSingleton</code>, review the javadoc for
other forms and options available.
</p>

<a name="Finding Classes"></a>
<h4>Finding Classes</h3>

<p>DiscoverClass finds and loads a class implementing a given interface.
DiscoverClass can pass a set of properties to the class if it implements
the <code>Service</code> interface (which doesn't support full-lifecycle
management as does the <code>SingletonService</code> interface).
</p>

<p>
DiscoverClass provides API's that instantiate a class, though it currently
supports only classes with default (zero-argument) constructors.
Unlike <code>DiscoverySingleton</code>, class instances are not cached,
so each call will result in a new object instance.
</p>

<p>
DiscoverClass is more oriented toward calling multiple times within similar contexts,
so it's use is slightly different than DiscoverSingleton: where as DiscoverSingleton provides
a set of static methods (no state), DiscoverClass must be instantiated before it is
used and maintains internal state.
</p>

<p>To find a class directly from user-code:
[NEED BETTER EXAMPLE]
<ul>
<pre>
    import org.apache.commons.discovery.DiscoverClass;
    import org.apache.commons.logging.LogFactory;
    ...
    DiscoverClass discoverClass = new DiscoverClass();
    Class logFactoryClass = (LogFactory)discoverClass.find(LogFactory.class);
</pre>
</ul>
In this case, DiscoverClass looks for the value of the system property
<code>org.apache.commons.logging.LogFactory</code>
for the name of a class that implements the <code>LogFactory</code> (abstract) class.
Failing that, it uses JDK1.3-style service discovery.
</p>

<p>To instantiate a class directly from user-code:
[NEED BETTER EXAMPLE]
<ul>
<pre>
    import org.apache.commons.discovery.DiscoverClass;
    import org.apache.commons.logging.LogFactory;
    ...
    DiscoverClass discoverClass = new DiscoverClass();
    LogFactory logFactoryClass = (LogFactory)discoverClass.newInstance(LogFactory.class);
</pre>
</ul>
</p>
<p>
As with DiscoverSingleton, DiscoverClass provides methods that
use <code>java.util.Properties</code> and a default implementation class name
to help determine the name of the class.
</p>

<a name="Integrating into Factories : Wrapping"></a>
<h3>3.  INTEGRATING INTO FACTORIES : WRAPPING</h3>


<p>In this example, a factory (such as is used in commons-logging)
internalizes the discovery mechanism, passing appropriate defaults
for a default properties file and a default implementation.
In this case, the factory plays double duty as both the service
to be discovered (abstract class), and the discovery mechanism.

<ul>
<pre>
import java.util.Properties;
import org.apache.commons.discovery.DiscoverSingleton;
import org.apache.commons.discovery.DiscoveryException;

public abstract class LogFactory
{
    protected static final String FACTORY_DEFAULT =
        org.apache.commons.logging.impl.DefaultLogFactory.class.getName();

    protected static final String FACTORY_PROPERTIES =
        "commons-logging.properties";

    /**
     * Protected constructor that is not available for public use.
     */
    protected LogFactory() { }

    public static LogFactory getFactory() throws ServiceException
    {
        return (LogFactory)DiscoverSingleton.find(LogFactory.class,
                                                  LogFactory.class,
                                                  FACTORY_PROPERTIES,
                                                  FACTORY_DEFAULT);
    }

    public static LogFactory getFactory(Properties properties)
        throws ServiceException
    {
        return (LogFactory)DiscoverSingleton.find(LogFactory.class,
                                                  LogFactory.class,
                                                  properties,
                                                  FACTORY_DEFAULT);
    }
    ...
}
</pre>
</ul>
Note the addition of one extra parameter to the <code>find</code>
method call.
The first parameter is a <i>root wrapper class</i>,
which delegates to the discovery mechanism.
This is necessary to all <code>Discovery</code>
to determine the correct class loaders to be used
in loading an implementation class.
The second parameter is the service interface/class
for which <code>Discovery</code> will be looking for an implementation.
In this example, they are the same class, as the LogFactory
is providing helper methods that 'wrap' <code>Discovery</code>.
</p>
 
<a name="Service Life Cycle Management"></a>
<h3>4.  SERVICE LIFE CYCLE MANAGEMENT</h3>

<p>Discovery supports life-cycle management through the <code>SingletonService</code> interface.
If a service implementation implements
the <code>SingletonService</code> interface then an
<code>init(String, Properties)</code>
method is invoked when the class in created by DiscoverSingleton,
and a <code>release()</code> method is invoked when DiscoverSingleton
removes the service from it's internal cache.
</p>

<p>Our example LogFactory (acting as both a factory and an SPI)
might be extended as follows:

<ul>
<pre>
<b>import org.apache.commons.discovery.SingletonService;</b>

public abstract class LogFactory <b>implements SingletonService</b>
{
    . . .
    <b>public abstract void init(String groupContext, Properties properties);</b>
    <b>public abstract void release();</b>

    /**
     * Release any internal references to previously created {@link LogFactory}
     * instances, after calling the instance method <code>release()</code> on
     * each of them.  This is useful environments like servlet containers,
     * which implement application reloading by throwing away a ClassLoader.
     * Dangling references to objects in that class loader would prevent
     * garbage collection.
     */
    <b>public static void releaseAll() {</b>
        <b>DiscoverSingleton.releaseAll(LogFactory.class);</b>
    <b>}</b>
}
</pre>
</ul>

<p>An example of how the properties might be used:
</p>
<ul>
<pre>
    public abstract void setAttribute(String name, Object value); 
    public abstract Object getAttribute(String name); 
 
    public void init(String groupContext, Properties properties) {
        if (properties != null) {
            Enumeration names = properties.propertyNames();
            while (names.hasMoreElements()) {
                String name = (String)names.nextElement();
                setAttribute(name, properties.getProperty(name));
            }
        }
    }
</pre>
</ul>

 
<a name="Service Groups"></a>
<h3>4.  Service Groups</h3>

<p>The <code>Service.init<code> method includes
a <code>groupContext</code> parameter.
This parameter allows services to be discovered and categorized by different
groups.
</p>

<p>
When a service is located and loaded,
it is done so within the context
of a set of <i>properties</i> and a runtime environment
(in particular, the ClassLoader hierarchy).
It is cached by the <code>Discovery</code>.
What happens when a different configuration is desired?
</p>

<p>
The service <code>groupContext</code> parameter,
available for many forms of <code>Discovery.find</code>,
allows services to be discovered and cached
by common groups, independent of other groups.
</p>

<p>
It is suggested that service components that
<ul>
<li>use <code>Discovery</code> services, and that</li>
<li>provide a service (i.e. could be discovered)</li>
</ul>
accept the <code>groupContext</code> and propogate
it through to services it discovers.
The groupContext should be optional,
so two forms of each 'discovery' wrapper method
should be used:
<ul>
<pre>
    public static LogFactory getFactory() throws ServiceException
    ... as above ...

    public static LogFactory getFactory(Properties properties)
    ... as above ...

    public static LogFactory getFactory(<b>String groupContext</b>)
        throws ServiceException
    {
        return (LogFactory)DiscoverSingleton.find(LogFactory.class,
                                                  <b>groupContext</b>,
                                                  LogFactory.class,
                                                  FACTORY_PROPERTIES,
                                                  FACTORY_DEFAULT);
    }

    public static LogFactory getFactory(<b>String groupContext,</b>
                                        Properties properties)
        throws ServiceException
    {
        return (LogFactory)DiscoverSingleton.find(LogFactory.class,
                                                  <b>groupContext</b>,
                                                  LogFactory.class,
                                                  properties,
                                                  FACTORY_DEFAULT);
    }
</pre>
</ul>

</body>
</html>
